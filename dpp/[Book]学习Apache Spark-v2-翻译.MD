# Learning with Apache Spark 2

***set_daemon@126.com   2017-08-18  （如有侵权，请与我联系）***

翻译的原因有两个：尝试锻炼英语翻译能力，方便以后看其它资料；加深对spark的理解。

可在github https://github.com/PacktPublishing/Learning-Apache-Spark-2找到源码。







## 第9章  构建一个推荐系统

在上一章，我们介绍了在各种集群上搭建spark的概念。在这个课程和下一章，我们将看到一些实际使用例子。在这一章主要看如何构建一个推荐系统，这是大多数人正在用不同方式构建的一种系统。我们将包含以下主题：

​	1）推荐系统概览

​	2）为什么需要推荐系统

​	3）长尾现象

​	4）推荐的类型

​	5）推荐中的关键问题

​	6）基于内容的推荐

​	7）协同过滤

​	8）隐语义模型

本章希望可以给你一个推荐系统的很好介绍，并随之给出一个解决现实世界使用问题电影推荐具体的代码例子。

让我们开始吧。



#### 推荐系统是什么

我们几乎每天都与推荐系统打交道，比如你从Amazon上购买东西，在Netflix上观看电影，在Xbox上玩游戏，在google上查找新闻文章，在Spotify上听音乐。这些在线的应用基于你的历史记录或者与你有相似兴趣的用户给你推荐商品。

![amazon_recommendation_system.png](attachments/amazon_recommendation_system.png)



为什么推荐在我们生活中已经变成一件如此重大的事情，而15至20年以前在典型的由砖和水泥制造的商店中，这都闻所未闻？答案有赖于我们生活在一个物质极大丰富而不是匮乏的时代。我们也将更深入分析这个观点。20年以前，典型的零售商存储的商品数量都有限，原因是有限的货架空间和昂贵的房地产成本。

同样地，我们喜爱的电影院仅拥有有限的电影，我们的图书卖家仅拥有限的图书。我仍然记得20年以前，为了找一本Pascal图书，需要在不同商店中穿行，行走距离至少10英里，因为这不是一个热门的商品，在Islamabad主要的图书商店都没有库存。Web就没有这样货架空间的限制，因此，在Netflix上能找到的电影数量远超过任何代表性的影院。以此类推，在Amazon和eBay上能找到的产品数量比当前世界上任何一家零售商的要多出数十倍。什么让这一切变得可能？这可能归功于***[长尾现象](***https://www.wired.com/2004/10/tail/ ***)***。这种现象的思想就是，***如果你按受欢迎度给商品排序，而欢迎度是基于一个特殊商品的销售数量，零售商仅会售卖超过一定限度的商品，这个限度通常就是维持商品在库存中的成本（？）***。如图9.2所描述。

![long_tailer_phenomenon.png](attachments/long_tailer_phenomenon.png)



当依据单位销量来判断商品的受欢迎度，观察量大受欢迎和量小不太受欢迎的商品时，你可以看到长尾现象。零售商通常只会储备受欢迎的商品，并给它最佳性价比，而不太受欢迎的商品（在分割点右侧）只被在线商店存储。这种现象适用于所有类型的商品，包括图书、电影、歌曲和新闻文章，在趋向分割点右侧的曲线带被称为长尾。
更有趣的事情是如果你计算曲线下面的面积，例如AUC1,绿色覆盖的区域代表可在线商店和零售商店找到的商品，对比红色覆盖的区域代表只可在线找到的商品，可以发现AUC2通常即便不大于AUC1,但也相差无几。这些在线商品没法在零售店找到，实际上这类商品中有许多是很难找到的，在很多情况下用户并不知道确切的商品名，这时你需要向用户介绍这些新产品。事实上，你现在对商品有更多的选择，意味着你需要更好的过滤器，推荐引擎是这种情况下的解决方案。有许多熟知的案例，一些产品并不太好卖，结果导入到推荐引擎后表现极其惊人。

#### 推荐的类型
这里有三种推荐类型，我们将逐一介绍：
	1)人工推荐
	2)基于欢迎度的简单聚合推荐
	3)用户个性化推荐

###### 人工推荐
人工推荐是最简单而古老的推荐方式，这甚至与传统零售商相关。例如，如果你去你所地的影像商店，他们也许会在一个小通道里展示排名前十的电影，这通常是使用一些人工处理实现的。访问一些流行的网站，你可以看到喜爱收藏夹或员工推荐，这些并不考虑任何用户的参与(不是用户投票或其它方式产生的)。

###### 基于人气的简单聚合推荐
一些在线商店已经从人工推荐系统发展到另外一种更简单的用户商品推荐方式。在许多网站，默认的机制是采用当前售卖前十的商品展示成人气商品。相似地，如果你访问YouTube，你能看到最高人气的视频或热门视频。同样你访问Twitter时，你能看到最近用户正在推的热门话题。这类推荐基于普遍用户行为，并不指定特定的用户，通常是基于用户的聚合行为。

###### 用户特定推荐
为了从用户获得最好的参与，你必须针对特定用户裁剪推荐，而不是基于高层次的聚合或者人工挑选。用户更可能观看一部与他们之前看过的电影相似的影片，或者读一本与他们喜欢读的图书相似的书，而不是从前10列表中选出一部电影观看或一本书阅读。这种推荐最难做到准确，但能给出最好的结果，因此是本章的核心。

#### 用户特定推荐
在本章余下部分，我们将重点讨论用户特定的评级。让我们从考虑推荐系统的模型开始。
假设：
	C = 消费者集合
	I = 商品集合（可以是电影，图书，新闻等等）
	R = 评级集合。这是一个有序集合，更高数字表示特别商品的高喜爱度，更小数字表示特别商品的低喜爱度。通常数字是由0到1之间的实数表示。
我们定义一个功能函数u：组合消费者和商品配对，并将配对映射到特定的评级，即 u: C*I -> R。
如下实用矩阵的例子，表示用户与电影的集合：

|        | 教父1(Godfather I) | 教父2 (Godfather II) | 心灵捕手(good will hunting) | 美丽心灵(A Beautiful Mind） |
| ------ | ---------------- | ------------------ | ----------------------- | ---------------------- |
| Roger  |                  |                    | 1                       | 0.5                    |
| Aznan  | 1                | 0.7                | 0.2                     |                        |
| Fawad  | 0.9              | 0.8                | 0.1                     |                        |
| Adrian |                  |                    | 1                       | 0.8                    |


这个实用矩阵通常是一个稀疏矩阵，原因是用户对观看过的电影很少评级。这些未评级的区域可能是由于用户对电影评级不用心，或者简单的事实是他们对电影评级完全不上心（not bothered to rate the movies at all）。***推荐系统的目标是找出这些缺失值，识别出用户可能会评级很高的电影并将其推荐给用户***。

#### 推荐系统的关键问题
通常，推荐系统有三个关键问题：
	1) 收集已知的输入数据
	2) 通过已知评级预测未知
	3) 评测预测方法

###### 收集已知的输入数据
构建推荐系统的第一个临时里程碑是收集输入数据，即客户、产品和相关评级。由于在CRM或其它系统中已经有客户和产品数据，你将要从客户获得产品的评级。这有两个收集产品评级的方法：
	1）***明确的***：明确的评级意味着用户也许会明确地对一个特定商品评级，举例来说，Netflix的一部电影，Amazon的一本书或一个产品，等等。这是一种与用户打交道的直接方式，通常提供最高质量的数据。在真实生活中，尽管对商品评级会给一些激励，但非常少用户实际上会留下产品的评级。因此，对于任何有意义的预测练习，获取明确的评价是不可伸缩的（scalable）。
	2)***隐性的***：由于明确的评级通常不是一个选择，你可以决定从其他用户动作中推断出评级。例如，在网站上购买了产品而没有退回，也许可以意味着用户对该商品评级很高。同样的，一个视频流网站也许可以察觉到，如果用户观看了完整视频，这说明他们给了这个电影/视频一个正面的高评级，如果他们在半道就决定结束视频播放，这可以假定用户给这个产品负评级。这个隐性的评级有一个问题，仅能给正负评级，而不能给出高低评级。例如，产品购买暗示一个产品的正面评级，而未购买或退还暗示负面评级。然而，你不能用1(低）到10(高）的比例来度量此值，无论是5还是10.

###### 从已知评级预估未知
一旦准备好数据，我们能从已知评级推断出未知的评级。这里关键的问题是之前构建的实用矩阵是稀疏的，意味着大部分人不给商品评级。除此之外，我们必须处理冷启动问题，即新商品没有任何评级，同时新用户没有历史数据可以用来推荐新内容。从已知推荐/预估未知有三个主要方法：
	1)基于内容的推荐
	2)协同过滤
	3)隐语义模型

#### 基于内容的推荐
基于内容推荐背后的主要概念是将与用户已经高评级商品的相似商品推荐给用户，例如，如果我们谈论电影，将推荐相同演员、类型或导演的电影给用户。如果你是Facebook的用户，你会定期获得朋友推荐，被推荐的用户与你有一些类型的关联，如根据相同朋友，相同学校/大学，等等。基于内容的分级是通过生成商品和用户配置文件来完成的。商品配置文件是商品的基本特征，例如电影的场景，商品配置可能包括特征，如标题、演员和导演等等；基于用户的场景，其配置包括朋友集，或者他们一起居住、学习或工作的共同地方。商品配置基本上是一个向量，包含1或0个，依赖于特定的特征是不是商品配置的一部分。

在博客和新闻文章的场景，项目配置更复杂，它们基于文本特征，本质上是一些重要的词汇，通常用TF-IDF分数（词频-逆文档频次）来标识重要性。

<u>一旦你完成了商品的配置（profile 配置？），下一步是构建用户配置。带有前期搭建特定配置的商品（item）可能已经被用户评过级</u>。我们假设用户已经评级了n个商品，用i(1)到i(n)表示。获取用户配置的最简单方法是平均化商品的配置。假定N是商品配置的总数量，计算商品配置的平均数。不过，这只是一个很初步的方法，并不考虑用户除其它的商品外还有特定的商品，在这种情况下，我们可以采取加权平均，这里的权重即是用户给的评级。尽管如此，经验上来看，某些用户是随意评级者（easy raters），某些用户是严格评级者（hard raters），即，按1到5的比例范围来说，一些用户只会谨慎地给出1到3的评级分数，而其他人评级时更为慷慨，会愉快地给一部电影评级为5（如果电影的评级框都被勾选）。在这个特殊情况下，也许我们想要用该用户的平均评级来***归一化权重***。重要的是，要了解哪些特定的特征使得用户给电影评级很高，且特征的数量是任意的。

当我们得到用户配置和商品配置，下一个任务就是做出预估并推荐商品给用户。方法是，找一部用户之前未看过的电影，尝试预估出用户将要给这部电影可能的评级。评估所有的电影后，将用户可能会评级最高的电影推荐给用户。

###### 预估未知评级

用户和商品的配置都是存储大量不同特征的高维空间向量。有必要计算它们之间的距离，余弦相似度是一种主要的距离指标。对于任何用户，计算出用户和目录中所有的商品余弦相似度，取k最近邻的商品推荐给用户。

#### 基于内容推荐的优点和缺点

​	***优点***是：

​		1）基于内容的评级是基于内容和单个用户。不需要其它用户的评级，因此能从第一天就开始执行基于内容的推荐。

​		2）与协同过滤方法不同的是，你可以根据用户的独特口味量身打造出不同的选择，而不是全局普遍性的推荐。

​		3）基于内容的推荐允许推荐新的和人气的商品，因为是基于静态的配置（profile），而不是有多少人在之前看过/评级/买过它们，这也绕过了协同过滤的先评级（first-rate，第一步数据准备阶段需要评级）的问题（与缺点的第2条相反？）。

​		4）基于内容的推荐允许你对每个推荐给出解释。

​	***缺点***是：

​		1）对相关特征做特征工程有一定困难。特别是图像的特征极难找到。

​		2）<u>由于大量用户只对少量他们看过/买过的电影/商品评级，并不明确地对相似的电影给出兴趣度，推荐没有反馈数据</u>（？）。因此，有时候一部人气高的电影没有被推荐出去，因为用户没有给与该电影有相似特征的电影评过级，例如演员、类别等等。

​		3）冷启动仍然是个问题。如果一个用户从未评级过商品，很难给他们推荐出商品。既然这样，新用户通常是基于系统级别的人气推荐，一旦用户开始生成自己的配置，将采用其他的推荐方法。

#### 协同过滤

协同过滤遵循一个相对更简单的方法来做推荐。协同过滤背后的思想是假设你想推荐商品给特定的用户X，你会发现，基于好恶，与用户X有一群相似的用户，一旦我们得到这群用户，可以将群体中高评级的商品推荐给用户，引出了关键问题是如何找到相似的用户。某些度量相似度的方法包括：

​	1）Jaccard相似度

​	2）余弦相似度

​	3）中心化余弦相似度（Centered cosine similarity ）

在协同过滤例子之后给出了实例代码，我们将会看到更多的细节。由于电影是一个很容易与本主题相关的领域，所以还是以电影为例，之后还会有具体实现代码。我们有4个用户和电影集，这些用户做过一些评级：

|        | 教父1 （Godfather I） | 教父2（Godfather II） | 心灵捕手（Good Will Hunting） | 美丽心灵（A Beautiful Mide） |
| ------ | ----------------- | ----------------- | ----------------------- | ---------------------- |
| Roger  |                   |                   | 5                       | 4                      |
| Aznan  |                   | 5                 | 2                       |                        |
| Fawad  | 5                 |                   | 1                       |                        |
| Adrian |                   |                   | 4                       |                        |



Roger和Fawad都对两部电影做了评级。为了理解两个用户之间的相似度，用X和Y来表示两个用户，为了创建相似度指标，将用到他们的评级向量，r(x)表示用户X的评级向量，r(y)表示用户Y的评级向量。如果你观察评级表格，可以看到我们有大量未知的评级，<u>这是影响计算推荐评估值的关键问题</u>。

此外，这里的关键目标是用户分组，通过用户的相似喜好将用户聚集到一个组。从表格可以看到，Roger和Adrian，对“心灵捕手”都评级很高，可以说是相似的；Aznan和Fawad是相似的，都对“教父1”和“教父2”评级很高，而同时对“心灵捕手”评级相对较低。此外，如果观察Roger和Fawad，他们是很不相似的，Roger对“心灵捕手”评级很高，而Fawad则相反给出较低评级。当用之前共享指标来对这些用户分组，要确保这些相似度必须计算恰当，因为这些分组将会直接影响在我们应用内的网站上的推荐效果。

###### Jaccard相似性

***Jaccard指数***（index），又称***Jaccard相似度***系数，是用于比较样本集的相似性和多样性的一种统计。由于本章主要目标不在于该系数，所以不对其细节做更深的探讨，您可以访问https://en.wikipedia.org/wiki/Jaccard_index来了解更多。在我们这个例子中，Jaccard相似度可以用数学公式表示，如下：

$$Sim(Roger,Faward) = |r(Roger)  \bigcap r(Fawad)|/|r(Roger) \bigcup r(Fawad)|$$

$$Sim(Roger,Adrian) = |r(Roger) \bigcap r(Adrian)| / |r(Roger) \bigcup r(Adrian)|$$

Roger和Fawad都看了两部电影，可以看到他们有十分不同的品味：

​	$$r(Roger) \bigcap r(Fawad) = 1$$

​	$$r(Roger) \bigcup r(Fawad) = 3$$

​	$$Sim(Roger,Fawad) = 1/3$$

另一方面，Roger和Adrian同样都看过两部电影，但有相似的品味（？难道表格中数据有缺失）：

​	$$r(Roger) \bigcap r(Adrian) = 1$$

​	$$r(Roger) \bigcup r(Adrian) = 3$$

​	$$Sim(Roger,Adrian) = 1/3$$

这个例子揭示了Jaccard相似度系数的缺点，它只是用了评级的个数，而非真实能真正表示用户之间相似度和品味的评级数值。

###### 余弦相似度

余弦相似度是另一种非零向量之间相似度的衡量方法，计算两者间的夹角余弦值。从http://bit.ly/1V8H7Vp 可以了解更多余弦相似度的信息。本质上，我们将不同用户的评级数据处理成评级向量。余弦相似度，要求不能有未知评级，为了完善这个向量和评级矩阵，我们可以将缺失值填充为0，这个评级矩阵看起来像这样：

|        | 教父1 Godfather I | 教父2 Godfather II | 心灵捕手Good WIll Hunting | 美丽心灵A Beautiful Mide |
| ------ | --------------- | ---------------- | --------------------- | -------------------- |
| Roger  | 0               | 0                | 5                     | 4                    |
| Aznan  | 0               | 5                | 2                     |                      |
| Fawad  | 5               | 0                | 1                     | 0                    |
| Adrian | 0               | 0                | 4                     | 0                    |

计算Roger和Fawad的余弦相似度，其结果如下：

​	$$Sim(Roger,Fawad) = 0.153​$$

然而，当我们计算Roger和Adrian之间的余弦相似度，其结果截然相反：

​	![$$Sim(Roger,Adrian) = 0.780$$0](http://latex.codecogs.com/gif.latex?Sim(Roger,Adrian)=0.780)

这三个评级向量的余弦相似度清晰地表明，与Roger和Fawad之间的相似度比较而言，Roger和Adrian之间有更多相似的兴趣。这也很直观。然而，余弦相似度的假设存在一个轻微的问题，我们设定丢失值为0，这是由评级值的数值本质所决定，且意味着丢失的评级是负评级。如果Adrian没有给“美丽心灵”评级，可假设其评级是负的。这不是正确的，而且当面对更大、更多样化数据集时，会得到一个负结果。

另外，我们还没有考虑随意评级者（easy raters）和严格评级者（hard raters），这是一个有趣的问题。例如，你也许会看到这样的用户，对于确实喜欢的电影会给出5分的评级，而另一类用户对一部很好的电影只会给3分评级，事实上这类用户确实喜欢这部电影。这种情况如何度量？怎么处理这个问题？答案是使用***中心化余弦法***，也可以称为***Pearson相关性***。



###### 中心化余弦（Pearson相关性）

为了计算中心化余弦，我们将对用户的评级归一化处理，通常是减去用户评级的平均数得到；除此之外，我们将空白值按0处理，但有意思的事情是这个值将会以0为中心上下浮动。可以用不同的数据集来尝试一下。



###### 预估未知评级

至此，我们已经知道用何种指标来显示用户与其他用户之间的相似，用户与其他用户之间的相异。我们计算用户与其他每个用户之间的相似度，并选出具有相似度值最高的前k个用户，这被称为N集。一旦得到这个集合，我们可以做出预估。我们现在想知道用户将对一个特定的产品I会做出什么样的评级：

​	***选项1***：实现这个需求的最简单方法是，从相邻用户中取出产品I的评级做平均值，使用该值作为对该用户评级预估。

​	***选项2***：采用加权平均。我们可以用平均值来对相似度值做权重。例如，使用相邻N用户的数据，对N中的每一个用户y，以用户x和y的相似度作为用户y对商品I的评级的权重，这样就可以得到用户x对商品I的评级预估值。

​	***选项3***：我们刚看到了“用户-用户”的协同过滤处理，这同样适用于“商品-商品”的协同过滤。方法是，取商品I，找出与商品I相似的商品，基于相似商品的评级预估该商品的评级。“用户-用户”模型中的指标也同样适用于此模型。在实践时，大多预估都是用”用户-用户“协同过滤和”商品-商品“协同过滤的组合方法实现的。



#### 隐语义方法（Latent factor methods）

























